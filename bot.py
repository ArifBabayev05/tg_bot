import os
import json
import logging
from uuid import uuid4
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ContextTypes, ConversationHandler
from telegram.error import TelegramError
from config import TOKEN, ADMIN_CHAT_ID
from PIL import Image
import io

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

LANGUAGES = ["Az…ôrbaycan", "ƒ∞ngilis", "Rus"]

# Conversation States
(UPLOAD_SLIDE, UPLOAD_NAME, UPLOAD_CATEGORY, UPLOAD_PRICE, UPLOAD_CARD,
 UPLOAD_IMAGE, UPLOAD_LANGUAGE, UPLOAD_PAGES, SEARCH_TYPE, SEARCH_CATEGORY, 
 SELECT_SLIDE, CONFIRM_PAYMENT, SEARCH_OTHER_CATEGORY, SEARCH_LANGUAGE,
 MY_SLIDES, SELECT_SLIDE_ACTION, EDIT_FIELD, EDIT_VALUE) = range(18)



DB_FILE = "db.json"

# M…ô≈ühur d…ôrs kateqoriyalarƒ±
CATEGORIES = [
    "IT", "Riyaziyyat", "Elektronika", "English", "Biznes v…ô ƒ∞dar…ôetm…ô",
    "ƒ∞qtisadiyyat", "Dizayn", "Memarlƒ±q", "Neft-Qaz", "Dil√ßilik",
    "Tibb", "Tarix", "H√ºquq", "S∆èT∆èMM", "Dig…ôr"
]

def load_slides():
    if os.path.exists(DB_FILE):
        try:
            with open(DB_FILE, 'r', encoding='utf-8') as f:
                slides = json.load(f)
                # Ensure each slide has a sales field
                for slide in slides:
                    if 'sales' not in slide:
                        slide['sales'] = 0
                return slides
        except json.JSONDecodeError:
            logger.error("Error decoding db.json. Creating empty database.")
            return []
    return []



def save_slide(slide):
    # Ensure file extension exists
    if 'file_extension' not in slide:
        slide['file_extension'] = os.path.splitext(slide['file'])[1].lower()
    if 'file_type' not in slide:
        slide['file_type'] = {
            '.pdf': 'application/pdf',
            '.ppt': 'application/vnd.ms-powerpoint',
            '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
        }.get(slide['file_extension'], 'application/pdf')
    
    slides = load_slides()
    slides.append(slide)
    with open(DB_FILE, 'w', encoding='utf-8') as f:
        json.dump(slides, f, indent=2, ensure_ascii=False)

# -- Error Handler --
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Update {update} caused error {context.error}")
    if update and (update.message or update.callback_query):
        reply_func = update.message.reply_text if update.message else update.callback_query.message.reply_text
        await reply_func("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin v…ô ya @UniSlayd il…ô …ôlaq…ô saxlayƒ±n.")

# -- Start Command --
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message:
        user = update.message.from_user
        chat_id = update.message.chat_id
        reply_func = update.message.reply_text
    elif update.callback_query:
        user = update.callback_query.from_user
        chat_id = update.callback_query.message.chat_id
        reply_func = update.callback_query.message.reply_text
    else:
        logger.error("No valid message or callback query found in update")
        return ConversationHandler.END

    logger.info(f"User {user.id} ({user.full_name}) started the bot")
    
    context.user_data.clear()
    
    keyboard = [
        [InlineKeyboardButton("üì§ Slayd y√ºkl…ô", callback_data='upload')],
        [InlineKeyboardButton("üîç Slayd axtar", callback_data='search')]
    ]
    
    await reply_func(
        f"Salam {user.first_name}! UniSlayd botuna xo≈ü g…ôlmisiniz!\n\n"
        "Bu bot vasit…ôsil…ô universitet t…ôqdimatlarƒ±nƒ± payla≈üa v…ô ya axtara bil…ôrsiniz.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return ConversationHandler.END

# -- Handle Initial Choice --
async def handle_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user = query.from_user
    
    if query.data == 'upload':
        logger.info(f"User {user.id} ({user.full_name}) selected upload option")
        await query.message.reply_text(
        "Z…ôhm…ôt olmasa slayd faylƒ±nƒ± g√∂nd…ôr (max 30MB):\n"
        "D…ôst…ôkl…ôn…ôn formatlar: PDF, PPT, PPTX\n"
        "ƒ∞st…ônil…ôn vaxt /cancel yazaraq …ôm…ôliyyatƒ± l…ôƒüv ed…ô bil…ôrsiniz."
        )
        return UPLOAD_SLIDE
    elif query.data == 'search':
        logger.info(f"User {user.id} ({user.full_name}) selected search option")
        keyboard = [
            [InlineKeyboardButton("üìõ Ad il…ô axtar", callback_data='search_by_name')],
            [InlineKeyboardButton("üìö Kateqoriya il…ô axtar", callback_data='search_by_category')],
            [InlineKeyboardButton("üåê Dil…ô g√∂r…ô axtar", callback_data='search_by_language')]
        ]
        await query.message.reply_text(
        "Axtarƒ±≈ü √ºsulunu se√ßin:\n"
        "ƒ∞st…ônil…ôn vaxt /cancel yazaraq …ôm…ôliyyatƒ± l…ôƒüv ed…ô bil…ôrsiniz.",
        reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SEARCH_TYPE

# -- Cancel Command --
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    logger.info(f"User {user.id} ({user.full_name}) canceled the operation")
    
    await update.message.reply_text(
        "∆èm…ôliyyat l…ôƒüv edildi. Yenid…ôn ba≈ülamaq √º√ß√ºn /start …ômrini istifad…ô ed…ô bil…ôrsiniz.",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

# -- Upload Flow --
async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    
    if not update.message.document:
        await update.message.reply_text("Z…ôhm…ôt olmasa PDF v…ô ya PowerPoint faylƒ± g√∂nd…ôrin.")
        return UPLOAD_SLIDE
    
    document = update.message.document
    mime_type = document.mime_type
    
    # D…ôst…ôkl…ôn…ôn MIME tipl…ôri
    supported_types = {
        'application/pdf': '.pdf',
        'application/vnd.ms-powerpoint': '.ppt',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx'
    }
    
    if mime_type not in supported_types:
        await update.message.reply_text(
            "Yalnƒ±z PDF v…ô PowerPoint (PPT/PPTX) fayllarƒ± d…ôst…ôkl…ônir.\n"
            "Z…ôhm…ôt olmasa d√ºzg√ºn formatda fayl g√∂nd…ôrin."
        )
        return UPLOAD_SLIDE
    
    if document.file_size > 30 * 1024 * 1024:  # 30MB
        await update.message.reply_text("Fayl h…ôcmi 30MB-dan b√∂y√ºkd√ºr. Z…ôhm…ôt olmasa daha ki√ßik fayl g√∂nd…ôrin.")
        return UPLOAD_SLIDE

    logger.info(f"User {user.id} ({user.full_name}) uploaded file: {document.file_name} ({mime_type})")
    
    try:
        # Faylƒ±n orijinal adƒ±nƒ± v…ô geni≈ül…ônm…ôsini saxla
        original_filename = document.file_name
        file_extension = os.path.splitext(original_filename)[1].lower()
        
        if file_extension not in ['.pdf', '.ppt', '.pptx']:
           file_extension = supported_types[mime_type]
        # ∆èg…ôr faylƒ±n geni≈ül…ônm…ôsi t…ôkrarlanƒ±rsa, onu t…ômizl…ô
        if original_filename.lower().endswith(file_extension + file_extension):
            original_filename = original_filename[:-len(file_extension)]
        elif not original_filename.lower().endswith(file_extension):
            original_filename = original_filename + file_extension
        
        
        # Yeni fayl adƒ± yarat
        filename = f"{uuid4()}_{original_filename}"
        file_path = os.path.join("downloads", filename)
        
        logger.debug(f"Saving slide file to: {file_path}")
        
        # Faylƒ± y√ºkl…ô
        file = await document.get_file()
        await file.download_to_drive(file_path)
        
        # Faylƒ±n d√ºzg√ºn y√ºkl…ôndiyini yoxla
        if not os.path.exists(file_path):
            raise Exception(f"Failed to save file: {file_path}")
        
        context.user_data['slide_file'] = file_path
        context.user_data['file_type'] = mime_type
        context.user_data['file_extension'] = file_extension
        
        await update.message.reply_text("Slaydƒ±n adƒ±nƒ± daxil et:")
        return UPLOAD_NAME
        
    except TelegramError as e:
        logger.error(f"Error downloading file: {e}")
        await update.message.reply_text("Fayl y√ºkl…ôn…ôrk…ôn x…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return UPLOAD_SLIDE
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await update.message.reply_text("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return UPLOAD_SLIDE

async def handle_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    name = update.message.text.strip()
    
    if not name:
        await update.message.reply_text("Adƒ± bo≈ü ola bilm…ôz. Z…ôhm…ôt olmasa slaydƒ±n adƒ±nƒ± daxil et:")
        return UPLOAD_NAME
    
    logger.info(f"User {user.id} entered slide name: {name}")
    context.user_data['name'] = name
    
    # Kateqoriyalarƒ± 3 s√ºtun x 5 s…ôtir formatƒ±nda g√∂st…ôr
    keyboard = []
    for i in range(0, len(CATEGORIES), 3):
        row = [
            InlineKeyboardButton(CATEGORIES[j], callback_data=f"category_{CATEGORIES[j]}")
            for j in range(i, min(i + 3, len(CATEGORIES)))
        ]
        keyboard.append(row)
    
    await update.message.reply_text(
        "Slaydƒ±n kateqoriyasƒ±nƒ± se√ßin:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return UPLOAD_CATEGORY

async def handle_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    category = query.data.replace("category_", "")
    
    if category == "Dig…ôr":
        await query.message.reply_text("Z…ôhm…ôt olmasa kateqoriya adƒ±nƒ± daxil edin:")
        return UPLOAD_CATEGORY
    else:
        logger.info(f"User {query.from_user.id} selected category: {category}")
        context.user_data['category'] = category
        
        # ƒ∞lk √∂nc…ô qiym…ôti soru≈ü
        await query.message.reply_text(
            "Slaydƒ±n qiym…ôtini AZN il…ô daxil edin:\n"
            "Qeyd: Satƒ±≈ü ba≈ü tutduqda m…ôbl…ôƒüin 70%-i siz…ô √∂d…ônil…ôc…ôk."
        )
        return UPLOAD_PRICE

async def handle_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        price = float(update.message.text.strip())
        if price <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("Z…ôhm…ôt olmasa d√ºzg√ºn m…ôbl…ôƒü daxil edin (m…ôs: 5 v…ô ya 5.5):")
        return UPLOAD_PRICE
    
    logger.info(f"User {update.message.from_user.id} entered price: {price}")
    context.user_data['price'] = price
    
    # Dil se√ßimi √º√ß√ºn klaviatura
    keyboard = [[InlineKeyboardButton(lang, callback_data=f"lang_{lang}")] for lang in LANGUAGES]
    
    await update.message.reply_text(
        "T…ôqdimatƒ±n dilini se√ßin:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return UPLOAD_LANGUAGE

async def handle_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    language = query.data.replace("lang_", "")
    logger.info(f"User {query.from_user.id} selected language: {language}")
    context.user_data['language'] = language
    
    await query.message.reply_text(
        "T…ôqdimatƒ±n s…ôhif…ô sayƒ±nƒ± daxil edin:\n"
        "R…ôq…ôm olaraq yazƒ±n (m…ôs: 15)"
    )
    return UPLOAD_PAGES

async def handle_pages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        pages = int(update.message.text.strip())
        if pages <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("Z…ôhm…ôt olmasa d√ºzg√ºn s…ôhif…ô sayƒ± daxil edin (m…ôs: 15):")
        return UPLOAD_PAGES
    
    logger.info(f"User {update.message.from_user.id} entered page count: {pages}")
    context.user_data['pages'] = pages
    
    await update.message.reply_text(
        "Kart n√∂mr…ônizi daxil edin:\n"
        "Qeyd: Bu kart n√∂mr…ôsin…ô satƒ±≈ü ba≈ü tutduqda √∂d…ôni≈üiniz g√∂nd…ôril…ôc…ôk."
    )
    return UPLOAD_CARD
async def handle_card(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:  # Callback query varsa (geri d√ºym…ôsin…ô basƒ±lƒ±bsa)
        query = update.callback_query
        await query.answer()
        
        if query.data == "back_to_pages":
            # S…ôhif…ô sayƒ±na qayƒ±t
            keyboard = [[InlineKeyboardButton("üîô Geri", callback_data="back_to_language")]]
            await query.message.reply_text(
                "T…ôqdimatƒ±n s…ôhif…ô sayƒ±nƒ± daxil edin:",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return UPLOAD_PAGES
    
    # Normal mesaj g…ôlibs…ô (kart n√∂mr…ôsi daxil edilibs…ô)
    elif update.message:
        user = update.message.from_user
        card = update.message.text.strip()
        
        if not card:
            keyboard = [[InlineKeyboardButton("üîô Geri", callback_data="back_to_pages")]]
            await update.message.reply_text(
                "Kart n√∂mr…ôsi bo≈ü ola bilm…ôz. Z…ôhm…ôt olmasa kart n√∂mr…ôni daxil et:",
                # reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return UPLOAD_CARD
        
        logger.info(f"User {user.id} entered card number")
        context.user_data['card'] = card
        
        # Geri qayƒ±tma d√ºym…ôsi …ôlav…ô et
        keyboard = [[InlineKeyboardButton("üîô Geri", callback_data="back_to_card")]]
        
        await update.message.reply_text(
            "Slayddan 1-2 ≈ü…ôkil g√∂nd…ôr:\n"
            "Bu ≈ü…ôkill…ôr axtarƒ±≈ü zamanƒ± n√ºmun…ô kimi g√∂st…ôril…ôc…ôk.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return UPLOAD_IMAGE
    
    return ConversationHandler.END
async def handle_category_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    category = update.message.text.strip()
    
    if not category:
        await update.message.reply_text("Kateqoriya adƒ± bo≈ü ola bilm…ôz. Z…ôhm…ôt olmasa kateqoriya adƒ±nƒ± daxil edin:")
        return UPLOAD_CATEGORY
    
    logger.info(f"User {user.id} entered custom category: {category}")
    context.user_data['category'] = category
    await update.message.reply_text("Kart n√∂mr…ônizi daxil edin:\n"
        "Qeyd: Bu kart n√∂mr…ôsin…ô satƒ±≈ü ba≈ü tutduqda √∂d…ôni≈üiniz g√∂nd…ôril…ôc…ôk.")
    return UPLOAD_CARD



async def handle_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    
    if not update.message.photo:
        await update.message.reply_text("Z…ôhm…ôt olmasa bir ≈ü…ôkil g√∂nd…ôrin.")
        return UPLOAD_IMAGE
    
    try:
        photo = update.message.photo[-1]
        image_path = f"images/{uuid4()}.jpg"
        
        # ≈û…ôkili y√ºkl…ô
        file = await photo.get_file()
        image_bytes = await file.download_as_bytearray()
        
        # ≈û…ôkili Pillow il…ô a√ß v…ô t…ômizl…ô
        image = Image.open(io.BytesIO(image_bytes))
        
        # ≈û…ôkili RGB formatƒ±na √ßevir
        image = image.convert("RGB")
        
        # Maksimum √∂l√ß√ºs√ºn√º t…ôyin et (m…ôs…ôl…ôn, 1280x1280)
        max_size = (1280, 1280)
        image.thumbnail(max_size, Image.Resampling.LANCZOS)
        
        # ≈û…ôklin √∂l√ß√ºs√ºn√º ki√ßilt (keyfiyy…ôti azaldaraq)
        output = io.BytesIO()
        image.save(output, format="JPEG", quality=70, optimize=True)
        output.seek(0)
        
        # ≈û…ôkil √∂l√ß√ºs√ºn√º yoxla (Telegram ≈ü…ôkill…ôr √º√ß√ºn 10MB limit var)
        image_size = len(output.getvalue()) / (1024 * 1024)  # MB olaraq
        logger.debug(f"Processed image size: {image_size:.2f} MB")
        
        if image_size > 10:
            logger.warning(f"Image size too large: {image_size:.2f} MB, attempting to reduce further")
            # Daha √ßox ki√ßilt
            output = io.BytesIO()
            image.save(output, format="JPEG", quality=50, optimize=True)
            output.seek(0)
            image_size = len(output.getvalue()) / (1024 * 1024)
            logger.debug(f"Reduced image size: {image_size:.2f} MB")
            
            if image_size > 10:
                raise Exception(f"Image size still too large after compression: {image_size:.2f} MB")
        
        # ≈û…ôkili fayl olaraq saxla
        with open(image_path, 'wb') as f:
            f.write(output.getvalue())
        
        # Faylƒ±n d√ºzg√ºn saxlanƒ±b saxlanmadƒ±ƒüƒ±nƒ± yoxla
        if not os.path.exists(image_path):
            raise Exception("Failed to save image file")
        
        logger.info(f"User {user.id} uploaded a preview image: {image_path}, size: {image_size:.2f} MB")
        
        if 'images' not in context.user_data:
            context.user_data['images'] = []
        
        context.user_data['images'].append(image_path)
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ Tamamla", callback_data='finish_upload')],
            [InlineKeyboardButton("‚ûï Daha bir ≈ü…ôkil …ôlav…ô et", callback_data='add_more')]
        ]
        
        await update.message.reply_text(
            f"{len(context.user_data['images'])} ≈ü…ôkil y√ºkl…ôndi. N…ô etm…ôk ist…ôyirsiniz?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return UPLOAD_IMAGE
    
    except Exception as e:
        logger.error(f"Error processing image for user {user.id}: {str(e)}")
        await update.message.reply_text(f"≈û…ôkil y√ºkl…ôn…ôrk…ôn x…ôta ba≈ü verdi: {str(e)}. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return UPLOAD_IMAGE
    
async def handle_image_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'add_more':
        await query.message.reply_text("Z…ôhm…ôt olmasa daha bir ≈ü…ôkil g√∂nd…ôr:")
        return UPLOAD_IMAGE
    
    elif query.data == 'finish_upload':
        if 'images' not in context.user_data or not context.user_data['images']:
            await query.message.reply_text("∆èn azƒ± bir ≈ü…ôkil y√ºkl…ôm…ôlisiniz. Z…ôhm…ôt olmasa ≈ü…ôkil g√∂nd…ôrin:")
            return UPLOAD_IMAGE
        
        try:
            slide_id = str(uuid4())
            user = query.from_user
            
            # Get file extension and type
            file_path = context.user_data['slide_file']
            file_extension = os.path.splitext(file_path)[1].lower()
            
            # Get friendly file type name
            file_type_names = {
                '.pdf': 'PDF',
                '.ppt': 'PowerPoint',
                '.pptx': 'PowerPoint'
            }
            friendly_file_type = file_type_names.get(file_extension, 'Unknown')

            # Check if all required fields exist
            required_fields = ['name', 'category', 'price', 'card', 'slide_file', 'images']
            missing_fields = [field for field in required_fields if field not in context.user_data]
            
            if missing_fields:
                raise ValueError(f"Missing required fields: {', '.join(missing_fields)}")
            
            # Create pending upload with all required fields
            pending_upload = {
                "slide_id": slide_id,
                "user_id": user.id,
                "user_name": user.full_name,
                "name": context.user_data['name'],
                "category": context.user_data['category'],
                "price": float(context.user_data['price']),  # Convert to float
                "language": context.user_data.get('language', 'Nam…ôlum'),
                "pages": context.user_data.get('pages', 0),
                "card": context.user_data['card'],
                "file": context.user_data['slide_file'],
                "images": context.user_data['images'],
                "owner": user.id,
                "owner_name": user.full_name,
                "timestamp": str(query.message.date)
            }
            
            # Save pending upload
            save_pending_upload(pending_upload)
            
            # Admin…ô bildiri≈ü g√∂nd…ôr
            admin_text = (
                f"üì§ Yeni slayd y√ºkl…ôndi!\n"
                f"ƒ∞stifad…ô√ßi: {user.full_name} (ID: {user.id})\n"
                f"Slayd: {context.user_data['name']}\n"
                f"Kateqoriya: {context.user_data['category']}\n"
                f"Dil: {context.user_data.get('language', 'Nam…ôlum')}\n"
                f"S…ôhif…ô sayƒ±: {context.user_data.get('pages', 0)}\n"
                f"Qiym…ôt: {context.user_data['price']} AZN\n"
                f"Format: {friendly_file_type} ({file_extension})\n"
                f"Kart: {context.user_data['card']}"
            )
            
            # T…ôsdiq v…ô R…ôdd et d√ºym…ôl…ôri
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ T…ôsdiq Et", 
                        callback_data=f"approve_upload_{user.id}_{slide_id}"),
                    InlineKeyboardButton("‚ùå R…ôdd Et", 
                        callback_data=f"reject_upload_{user.id}_{slide_id}")
                ]
            ]

            # Send preview images and notification to admin
            for image_path in context.user_data['images']:
                await context.bot.send_photo(
                    chat_id=ADMIN_CHAT_ID,
                    photo=open(image_path, 'rb')
                )

            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text=admin_text,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Send the document to admin with correct file extension
            try:
                file_extension = context.user_data.get('file_extension', '.pdf')  # Use stored extension, default to .pdf
                filename = f"{pending_upload['name']}{file_extension}"
                with open(pending_upload['file'], 'rb') as f:
                    await context.bot.send_document(
                        chat_id=ADMIN_CHAT_ID,
                        document=f,
                        filename=filename,
                        reply_markup=reply_markup
                    )
            except Exception as e:
                logger.error(f"Failed to send document to admin: {e}")
                await context.bot.send_message(
                    chat_id=ADMIN_CHAT_ID,
                    text=admin_text + f"\n\n‚ö†Ô∏è Document faylƒ± g√∂nd…ôril…ô bilm…ôdi: {str(e)}",
                    reply_markup=reply_markup
                )
            
            # √ñnizl…ôm…ô ≈ü…ôkill…ôrini baytlar olaraq g√∂nd…ôr
            for i, img_path in enumerate(pending_upload['images'], start=1):
                try:
                    if not os.path.exists(img_path):
                        logger.error(f"Preview image not found: {img_path}")
                        await context.bot.send_message(
                            chat_id=ADMIN_CHAT_ID,
                            text=f"‚ö†Ô∏è √ñnizl…ôm…ô ≈ü…ôkli {i} tapƒ±lmadƒ±: {img_path}"
                        )
                        continue
                    
                    # ≈û…ôkili baytlar olaraq oxu
                    with open(img_path, 'rb') as f:
                        image_bytes = f.read()
                        logger.debug(f"Preview image {i} loaded as bytes, size: {len(image_bytes) / 1024:.2f} KB")
                    
                    # ≈û…ôkili baytlar olaraq g√∂nd…ôr
                    await context.bot.send_photo(
                        chat_id=ADMIN_CHAT_ID,
                        photo=image_bytes,
                        caption=f"√ñnizl…ôm…ô ≈ü…ôkli {i} - Slayd: {pending_upload['name']}"
                    )
                    logger.info(f"Successfully sent preview image {i} as bytes")
                
                except Exception as e:
                    logger.error(f"Failed to send preview image {i} as bytes: {e}")
                    await context.bot.send_message(
                        chat_id=ADMIN_CHAT_ID,
                        text=f"‚ö†Ô∏è √ñnizl…ôm…ô ≈ü…ôkli {i} y√ºkl…ôn…ô bilm…ôdi."
                    )
            
            # ƒ∞stifad…ô√ßiy…ô t…ôsdiq g√∂zl…ôm…ô mesajƒ±
            await query.message.reply_text(
                "‚úÖ Slaydƒ±nƒ±z qeyd…ô alƒ±ndƒ±!\n\n"
                "Admin t…ôsdiq etdikd…ôn sonra slayd payla≈üƒ±lanlar siyahƒ±sƒ±na …ôlav…ô olunacaq.\n"
                "T…ô≈ü…ôkk√ºrl…ôr!"
            )
            
            logger.info(f"User {user.id} ({user.full_name}) submitted slide for approval: {pending_upload['name']}")
            
            context.user_data.clear()
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"Error processing upload: {e}")
            await query.message.reply_text("Slayd qeyd…ô alƒ±nark…ôn x…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
            return ConversationHandler.END
        
async def reject_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if str(query.message.chat_id) != str(ADMIN_CHAT_ID):
        await query.message.reply_text("Bu …ômr yalnƒ±z admin √º√ß√ºn …ôl√ßatandƒ±r.")
        return
    
    try:
        parts = query.data.split('_')
        user_id = int(parts[2])
        slide_id = parts[3]
        
        # M√ºv…ôqq…ôti y√ºkl…ôm…ôl…ôrd…ôn m…ôlumatƒ± tap
        pending_uploads = load_pending_uploads()
        upload = next((u for u in pending_uploads if u['user_id'] == user_id and u['slide_id'] == slide_id), None)
        
        if not upload:
            logger.error(f"Pending upload not found for user ID: {user_id}, slide ID: {slide_id}")
            await query.message.reply_text(f"Y√ºkl…ôm…ô m…ôlumatlarƒ± tapƒ±lmadƒ± (User ID: {user_id}, Slide ID: {slide_id}).")
            return
        
        # M√ºv…ôqq…ôti y√ºkl…ôm…ôl…ôrd…ôn sil
        remove_pending_upload(user_id, slide_id)
        
        # ƒ∞stifad…ô√ßiy…ô r…ôdd mesajƒ± g√∂nd…ôr
        await context.bot.send_message(
            chat_id=user_id,
            text=f"‚ùå Sizin slaydƒ±nƒ±z ('{upload['name']}') admin t…ôr…ôfind…ôn r…ôdd edildi.\n"
                 "Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin v…ô ya adminl…ô …ôlaq…ô saxlayƒ±n (@UniSlayd)."
        )
        
        # Admin…ô r…ôdd mesajƒ±
        await query.message.reply_text(f"‚úÖ Slayd (ID: {slide_id}) r…ôdd edildi.")
        
        logger.info(f"Admin rejected upload for user ID: {user_id}, slide ID: {slide_id}")
        
    except Exception as e:
        logger.error(f"Error rejecting upload: {e}")
        await query.message.reply_text(f"X…ôta: {str(e)}")
# -- Search Flow --
async def handle_search_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'search_by_name':
        await query.message.reply_text(
            "Axtarmaq ist…ôdiyiniz slaydƒ±n adƒ±nƒ± daxil edin:",
            reply_markup=ReplyKeyboardRemove()
        )
        return SEARCH_TYPE
        
    elif query.data == 'search_by_category':
        # Kateqoriyalarƒ± 3 s√ºtun x 5 s…ôtir formatƒ±nda g√∂st…ôr
        keyboard = []
        for i in range(0, len(CATEGORIES), 3):
            row = [
                InlineKeyboardButton(CATEGORIES[j], callback_data=f"search_category_{CATEGORIES[j]}")
                for j in range(i, min(i + 3, len(CATEGORIES)))
            ]
            keyboard.append(row)
        
        await query.message.reply_text(
            "Kateqoriyanƒ± se√ßin:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SEARCH_CATEGORY
        
    elif query.data == 'search_by_language':
        keyboard = [[InlineKeyboardButton(lang, callback_data=f"search_lang_{lang}")] for lang in LANGUAGES]
        keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
        
        await query.message.reply_text(
            "Hansƒ± dild…ô t…ôqdimat axtarƒ±rsƒ±nƒ±z?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SEARCH_LANGUAGE

async def handle_search_by_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    language = query.data.replace("search_lang_", "")
    
    logger.info(f"User {query.from_user.id} searched by language: {language}")
    
    slides = load_slides()
    results = [slide for slide in slides if slide.get('language', '').lower() == language.lower()]
    
    context.user_data['results'] = results
    
    if not results:
        await query.message.reply_text(
            f"'{language}' dilind…ô he√ß bir t…ôqdimat tapƒ±lmadƒ±.\n"
            "Ba≈üqa dild…ô axtarƒ±≈ü √º√ß√ºn /start yazaraq …ôsas menyuya qayƒ±dƒ±n."
        )
        return ConversationHandler.END
    
    keyboard = []
    for i, slide in enumerate(results):
        button_text = f"{slide['name']} [{slide.get('language', 'Nam…ôlum')}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await query.message.reply_text(
        f"'{language}' dilind…ô {len(results)} t…ôqdimat tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE

async def handle_search_by_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        logger.error("No message found in update")
        return SEARCH_TYPE
    
    user = update.message.from_user
    name = update.message.text.lower().strip()
    
    if not name:
        await update.message.reply_text("Slayd adƒ± bo≈ü ola bilm…ôz. Z…ôhm…ôt olmasa slaydƒ±n adƒ±nƒ± daxil edin:")
        return SEARCH_TYPE
    
    logger.info(f"User {user.id} ({user.full_name}) searched by name: {name}")
    
    slides = load_slides()
    results = [
        slide for slide in slides
        if name in slide['name'].lower()
    ]
    
    context.user_data['results'] = results
    
    if not results:
        await update.message.reply_text(
            f"'{name}' adƒ±na uyƒüun he√ß bir n…ôtic…ô tapƒ±lmadƒ±.\n"
            "Yeni axtarƒ±≈ü √º√ß√ºn ba≈üqa ad daxil edin v…ô ya /start yazaraq …ôsas menyuya qayƒ±dƒ±n."
        )
        return SEARCH_TYPE
    
    keyboard = []
    for i, slide in enumerate(results):
        # "category" sah…ôsinin m√∂vcudluƒüunu yoxla v…ô varsayƒ±lan d…ôy…ôr t…ôyin et
        category = slide.get('category', 'Nam…ôlum')
        button_text = f"{slide['name']} [Kateqoriya: {category}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await update.message.reply_text(
        f"'{name}' adƒ±na uyƒüun {len(results)} n…ôtic…ô tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE

async def handle_search_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    category = query.data.replace("search_category_", "")
    
    if category == "Dig…ôr":
        await query.message.reply_text("Z…ôhm…ôt olmasa kateqoriya adƒ±nƒ± daxil edin:")
        return SEARCH_OTHER_CATEGORY
    
    logger.info(f"User {query.from_user.id} searched by category: {category}")
    
    slides = load_slides()
    results = []
    for slide in slides:
        # 'category' sah…ôsinin m√∂vcudluƒüunu yoxla, yoxdursa bo≈ü string qaytar
        slide_category = slide.get('category', '').lower()
        if slide_category == category.lower():
            results.append(slide)
    
    context.user_data['results'] = results
    
    if not results:
        await query.message.reply_text(
            f"'{category}' kateqoriyasƒ±nda he√ß bir n…ôtic…ô tapƒ±lmadƒ±.\n"
            "Ba≈üqa kateqoriya se√ßm…ôk √º√ß√ºn /start yazaraq …ôsas menyuya qayƒ±dƒ±n."
        )
        return SEARCH_TYPE
    
    keyboard = []
    for i, slide in enumerate(results):
        button_text = f"{slide['name']} [Kateqoriya: {slide.get('category', 'Nam…ôlum')}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await query.message.reply_text(
        f"'{category}' kateqoriyasƒ±nda {len(results)} n…ôtic…ô tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE

async def handle_search_other_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        logger.error("No message found in update")
        return SEARCH_OTHER_CATEGORY
    
    user = update.message.from_user
    category = update.message.text.lower().strip()
    
    if not category:
        await update.message.reply_text("Kateqoriya adƒ± bo≈ü ola bilm…ôz. Z…ôhm…ôt olmasa kateqoriya adƒ±nƒ± daxil edin:")
        return SEARCH_OTHER_CATEGORY
    
    logger.info(f"User {user.id} ({user.full_name}) searched by custom category: {category}")
    
    slides = load_slides()
    results = []
    for slide in slides:
        # 'category' sah…ôsinin m√∂vcudluƒüunu yoxla v…ô varsayƒ±lan d…ôy…ôr t…ôyin et
        slide_category = slide.get('category', '').lower()
        if slide_category == category:
            results.append(slide)
    
    context.user_data['results'] = results
    
    if not results:
        await update.message.reply_text(
            f"'{category}' kateqoriyasƒ±nda he√ß bir n…ôtic…ô tapƒ±lmadƒ±.\n"
            "Ba≈üqa kateqoriya √º√ß√ºn /start yazaraq …ôsas menyuya qayƒ±dƒ±n."
        )
        return SEARCH_TYPE
    
    keyboard = []
    for i, slide in enumerate(results):
        button_text = f"{slide['name']} [Kateqoriya: {slide.get('category', 'Nam…ôlum')}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await update.message.reply_text(
        f"'{category}' kateqoriyasƒ±nda {len(results)} n…ôtic…ô tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE

async def handle_search_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    category = query.data.replace("search_category_", "")
    
    if category == "Dig…ôr":
        await query.message.reply_text("Z…ôhm…ôt olmasa kateqoriya adƒ±nƒ± daxil edin:")
        return SEARCH_OTHER_CATEGORY
    
    logger.info(f"User {query.from_user.id} searched by category: {category}")
    
    slides = load_slides()
    results = []
    for slide in slides:
        # 'category' sah…ôsinin m√∂vcudluƒüunu yoxla, yoxdursa bo≈ü string qaytar
        slide_category = slide.get('category', '').lower()
        if slide_category == category.lower():
            results.append(slide)
    
    context.user_data['results'] = results
    
    if not results:
        await query.message.reply_text(
            f"'{category}' kateqoriyasƒ±nda he√ß bir n…ôtic…ô tapƒ±lmadƒ±.\n"
            "Ba≈üqa kateqoriya se√ßm…ôk √º√ß√ºn /start yazaraq …ôsas menyuya qayƒ±dƒ±n."
        )
        return SEARCH_TYPE
    
    keyboard = []
    for i, slide in enumerate(results):
        button_text = f"{slide['name']} [Kateqoriya: {slide.get('category', 'Nam…ôlum')}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await query.message.reply_text(
        f"'{category}' kateqoriyasƒ±nda {len(results)} n…ôtic…ô tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE
async def back_to_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if 'results' not in context.user_data or not context.user_data['results']:
        keyboard = [
            [InlineKeyboardButton("üìõ Ad il…ô axtar", callback_data='search_by_name')],
            [InlineKeyboardButton("üìö Kateqoriya il…ô axtar", callback_data='search_by_category')]
        ]
        await query.message.reply_text(
            "Axtarƒ±≈ü √ºsulunu se√ßin:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SEARCH_TYPE
    
    keyboard = []
    for i, slide in enumerate(context.user_data['results']):
        button_text = f"{slide['name']} [Kateqoriya: {slide['category']}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"slide_{i}")])
    
    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
    
    await query.message.reply_text(
        f"Axtarƒ±≈ü n…ôtic…ôl…ôri:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SELECT_SLIDE

async def request_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    slide = context.user_data.get('selected_slide')
    if not slide:
        await query.message.reply_text("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return ConversationHandler.END
    
    payment_text = (
        f"üí∞ √ñd…ôni≈ü m…ôlumatlarƒ±:\n\n"
        f"üí≥ *Kart n√∂mr…ôsi:* `4098584494745886`\n\n"
        f"Z…ôhm…ôt olmasa bu kart n√∂mr…ôsin…ô {slide['price']} AZN m…ôbl…ôƒüind…ô √∂d…ôni≈ü edin v…ô "
        f"√∂d…ôni≈ü q…ôbzinin ≈ü…ôklini g√∂nd…ôrin. √ñd…ôni≈ü t…ôsdiql…ôn…ônd…ôn sonra "
        f"slayd siz…ô g√∂nd…ôril…ôc…ôk."
    )
    
    await query.message.reply_text(
        payment_text,
        parse_mode="Markdown"
    )
    
    await query.message.reply_text(
        "Z…ôhm…ôt olmasa √∂d…ôni≈ü etdiyiniz q…ôbzin ≈ü…ôklini g√∂nd…ôrin:"
    )
    return CONFIRM_PAYMENT

async def view_selected_slide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "main_menu":
        keyboard = [
            [InlineKeyboardButton("üì§ Slayd y√ºkl…ô", callback_data='upload')],
            [InlineKeyboardButton("üîç Slayd axtar", callback_data='search')]
        ]
        await query.message.reply_text(
            "∆èsas menyu:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ConversationHandler.END
    
    try:
        index = int(query.data.split('_')[1])
        slide = context.user_data['results'][index]
        context.user_data['selected_slide'] = slide
        
        logger.info(f"User {query.from_user.id} ({query.from_user.full_name}) selected slide: {slide['name']}")
        
        # Get values with defaults if fields don't exist
        category = slide.get('category', 'Nam…ôlum')
        price = slide.get('price', 0)  # Default price is 0 if not set
        
        info_text = (
            f"üìù *{slide['name']}*\n\n"
            f"üìå *Kateqoriya:* {category}\n"
            f"üåê *Dil:* {slide.get('language', 'Qeyd edilm…ôyib')}\n"
            f"üìÑ *S…ôhif…ô sayƒ±:* {slide.get('pages', 'Qeyd edilm…ôyib')}\n"
            f"üí∞ *Qiym…ôt:* {price} AZN\n"
            f"üí≥ *Kart n√∂mr…ôsi:* `4098584494745886`\n"
        )
        
        # √ñnizl…ôm…ô ≈ü…ôkill…ôrini g√∂nd…ôr
        if 'images' in slide and slide['images']:
            for i, img_path in enumerate(slide['images'], start=1):
                try:
                    if not os.path.exists(img_path):
                        logger.error(f"Image file not found: {img_path}")
                        continue
                        
                    with open(img_path, 'rb') as f:
                        await query.message.reply_photo(
                            photo=f,
                            parse_mode="Markdown"
                        )
                except Exception as e:
                    logger.error(f"Error sending preview image {i}: {e}")
                    continue
        
        await query.message.reply_text(
            info_text,
            parse_mode="Markdown"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ T…ôqdimatƒ± al", callback_data="buy")],
            [InlineKeyboardButton("üîô Geri", callback_data="back_to_results")]
        ]
        
        await query.message.reply_text(
            "N…ô etm…ôk ist…ôyirsiniz?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return CONFIRM_PAYMENT
        
    except Exception as e:
        logger.error(f"Error in view_selected_slide: {str(e)}")
        await query.message.reply_text(
            "X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin."
        )
        return ConversationHandler.END


async def reject_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if str(query.message.chat_id) != str(ADMIN_CHAT_ID):
        await query.message.reply_text("Bu …ômr yalnƒ±z admin √º√ß√ºn …ôl√ßatandƒ±r.")
        return
    
    try:
        user_id = int(query.data.split('_')[-1])
        
        # payments.json faylƒ±nƒ± yoxla
        if not os.path.exists('payments.json'):
            logger.error("Payments file not found")
            await query.message.reply_text("√ñd…ôni≈ü m…ôlumatlarƒ± faylƒ± tapƒ±lmadƒ±.")
            return
        
        with open('payments.json', 'r', encoding='utf-8') as f:
            payments = json.load(f)
        
        payment = next((p for p in payments if p['user_id'] == user_id), None)
        if not payment:
            logger.error(f"Payment data not found for user ID: {user_id}")
            await query.message.reply_text(f"√ñd…ôni≈ü m…ôlumatlarƒ± tapƒ±lmadƒ± (ID: {user_id}).")
            return
        
        # √ñd…ôni≈üi payments.json-dan sil
        payments = [p for p in payments if p['user_id'] != user_id]
        with open('payments.json', 'w', encoding='utf-8') as f:
            json.dump(payments, f, indent=2, ensure_ascii=False)
        
        # ƒ∞stifad…ô√ßiy…ô r…ôdd mesajƒ± g√∂nd…ôr
        await context.bot.send_message(
            chat_id=user_id,
            text=f"‚ùå √ñd…ôni≈üiniz admin t…ôr…ôfind…ôn r…ôdd edildi (Slayd: {payment['slide_name']}).\n"
                 "Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin v…ô ya adminl…ô …ôlaq…ô saxlayƒ±n (@UniSlayd)."
        )
        
        # Admin…ô r…ôdd mesajƒ±
        await query.message.reply_text(f"‚úÖ √ñd…ôni≈ü (ID: {user_id}) r…ôdd edildi.")
        
        logger.info(f"Admin rejected payment for user ID: {user_id}")
        
    except Exception as e:
        logger.error(f"Error rejecting payment: {e}")
        await query.message.reply_text(f"X…ôta: {str(e)}")

async def confirm_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    
    if not update.message.photo:
        await update.message.reply_text(
            "Z…ôhm…ôt olmasa √∂d…ôni≈ü q…ôbzinin ≈ü…ôklini g√∂nd…ôrin."
        )
        return ConversationHandler.END
    
    slide = context.user_data.get('selected_slide')
    if not slide:
        logger.error("No selected slide found in user_data")
        await update.message.reply_text("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return ConversationHandler.END
    
    try:
        payment_image = update.message.photo[-1]
        image_path = f"payments/{uuid4()}.jpg"
        
        # ≈û…ôkili y√ºkl…ô v…ô optimalla≈üdƒ±r
        file = await payment_image.get_file()
        image_bytes = await file.download_as_bytearray()
        
        # ≈û…ôkili Pillow il…ô a√ß v…ô optimalla≈üdƒ±r
        image = Image.open(io.BytesIO(image_bytes))
        image = image.convert("RGB")  # RGB formatƒ±na √ßevir
        
        # Maksimum √∂l√ß√ºs√ºn√º t…ôyin et (m…ôs…ôl…ôn, 640x640)
        max_size = (640, 640)
        image.thumbnail(max_size, Image.Resampling.LANCZOS)
        
        # B√ºt√ºn metadata-nƒ± t…ômizl…ô
        image_info = image.info.copy()
        image_info.pop('exif', None)
        image_info.pop('icc_profile', None)
        
        # ≈û…ôkili JPEG olaraq saxla
        output = io.BytesIO()
        image.save(output, format="JPEG", quality=70, optimize=True, **image_info)
        output.seek(0)
        
        # ≈û…ôkili fayl olaraq saxla
        with open(image_path, 'wb') as f:
            f.write(output.getvalue())
        
        # Faylƒ±n d√ºzg√ºn saxlanƒ±b-saxlanmadƒ±ƒüƒ±nƒ± yoxla
        if not os.path.exists(image_path):
            raise Exception(f"Failed to save image file: {image_path}")
        
        image_size = os.path.getsize(image_path) / 1024  # KB olaraq
        logger.info(f"User {user.id} ({user.full_name}) submitted payment for slide: {slide['name']}, image size: {image_size:.2f} KB")
        logger.debug(f"Slide file path: {slide['file']}, payment image path: {image_path}")
        
        # √ñd…ôni≈ü m…ôlumatlarƒ±nƒ± faylda saxla
        payment_data = {
            'user_id': user.id,
            'slide_file': slide['file'],
            'slide_name': slide['name'],
            'timestamp': str(update.message.date),
            'payment_image': image_path
        }
        if not os.path.exists('payments.json'):
            with open('payments.json', 'w', encoding='utf-8') as f:
                json.dump([], f, indent=2, ensure_ascii=False)
        
        with open('payments.json', 'r', encoding='utf-8') as f:
            payments = json.load(f)
        payments.append(payment_data)
        with open('payments.json', 'w', encoding='utf-8') as f:
            json.dump(payments, f, indent=2, ensure_ascii=False)
        
        admin_text = (
            f"üí∏ Yeni √∂d…ôni≈ü!\n"
            f"ƒ∞stifad…ô√ßi: {user.full_name} (ID: {user.id})\n"
            f"Slayd: {slide['name']}\n"
            f"Satƒ±cƒ±: {slide.get('owner_name', 'Nam…ôlum')} (ID: {slide.get('owner', 'Nam…ôlum')})\n"
            f"Kart: {slide['card']}\n"
        )
        
        # T…ôsdiq v…ô R…ôdd et d√ºym…ôl…ôri
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ T…ôsdiq Et", callback_data=f"approve_payment_{user.id}"),
                InlineKeyboardButton("‚ùå R…ôdd Et", callback_data=f"reject_payment_{user.id}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # ≈û…ôkili baytlar olaraq g√∂nd…ôr
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            await context.bot.send_photo(
                chat_id=ADMIN_CHAT_ID,
                photo=image_bytes,
                caption=admin_text,
                reply_markup=reply_markup
            )
            logger.info("Successfully sent payment image as bytes with buttons")
        except Exception as e:
            logger.error(f"Failed to send payment image as bytes: {e}")
            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text=admin_text,
                reply_markup=reply_markup
            )
        
        await update.message.reply_text(
            "‚úÖ √ñd…ôni≈üiniz qeyd…ô alƒ±ndƒ±!\n\n"
            "Admin √∂d…ôni≈üi t…ôsdiq etdikd…ôn sonra t…ôqdimat faylƒ± siz…ô g√∂nd…ôril…ôc…ôk.\n"
            "T…ô≈ü…ôkk√ºrl…ôr!"
        )
        
        return ConversationHandler.END
        
    except Exception as e:
        logger.error(f"Error processing payment: {e}")
        await update.message.reply_text(
            "√ñd…ôni≈ü q…ôbzi y√ºkl…ôn…ôrk…ôn x…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin."
        )
        return ConversationHandler.END
    
async def approve_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if str(query.message.chat_id) != str(ADMIN_CHAT_ID):
        await query.message.reply_text("Bu …ômr yalnƒ±z admin √º√ß√ºn …ôl√ßatandƒ±r.")
        return

    try:
        user_id = int(query.data.split('_')[2])
        
        # Load payments
        with open('payments.json', 'r', encoding='utf-8') as f:
            payments = json.load(f)
        
        # Find payment
        payment = next((p for p in payments if p['user_id'] == user_id), None)
        if not payment:
            raise ValueError(f"Payment not found for user ID: {user_id}")

        # Load slides
        slides = load_slides()
        
        # Find slide
        slide = next((s for s in slides if s['file'] == payment['slide_file']), None)
        if not slide:
            raise ValueError(f"Slide not found: {payment['slide_name']}")

        # Update sales count
        if 'sales' in slide:
            slide['sales'] += 1
        else:
            slide['sales'] = 1

        # Save updated slides
        with open(DB_FILE, 'w', encoding='utf-8') as f:
            json.dump(slides, f, indent=2, ensure_ascii=False)

        # Calculate seller amount (85% of price)
        seller_amount = float(slide['price']) * 0.85

        # Send payment details to admin
        await query.message.reply_text(
            f"üí∞ *√ñd…ôni≈ü edilm…ôlidir:*\n\n"
            f"üë§ ƒ∞stifad…ô√ßi ID: `{slide['owner']}`\n"
            f"üí≥ Kart: `{slide['card']}`\n"
            f"üíµ M…ôbl…ôƒü: *{seller_amount:.2f} AZN*\n"
            f"_(Satƒ±≈ü m…ôbl…ôƒüi: {slide['price']} AZN)_",
            parse_mode="Markdown"
        )

        # Send slide to buyer
        if os.path.exists(slide['file']):
            file_extension = os.path.splitext(slide['file'])[1].lower()
            with open(slide['file'], 'rb') as f:
                await context.bot.send_document(
                    chat_id=user_id,
                    document=f,
                    filename=f"{slide['name']}{file_extension}",
                    caption=f"T…ôqdimat: {slide['name']}"
                )

            # Notify buyer
            await context.bot.send_message(
                chat_id=user_id,
                text="‚úÖ √ñd…ôni≈üiniz t…ôsdiql…ôndi! Slayd faylƒ± yuxarƒ±da g√∂nd…ôrildi."
            )

            # Remove payment record
            payments = [p for p in payments if p['user_id'] != user_id]
            with open('payments.json', 'w', encoding='utf-8') as f:
                json.dump(payments, f, indent=2, ensure_ascii=False)

            # Confirm to admin
            await query.message.reply_text(f"‚úÖ ƒ∞stifad…ô√ßiy…ô (ID: {user_id}) slayd g√∂nd…ôrildi.")
        else:
            raise FileNotFoundError(f"Slide file not found: {slide['file']}")

    except Exception as e:
        logger.error(f"Error approving payment: {e}")
        await query.message.reply_text(f"X…ôta: {str(e)}")

# M√ºv…ôqq…ôti y√ºkl…ôm…ôl…ôri saxlamaq √º√ß√ºn fayl
PENDING_UPLOADS_FILE = "pending_uploads.json"

def load_pending_uploads():
    if os.path.exists(PENDING_UPLOADS_FILE):
        try:
            with open(PENDING_UPLOADS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError:
            logger.error(f"Error decoding {PENDING_UPLOADS_FILE}. Creating empty database.")
            return []
    return []

def save_pending_upload(upload):
    uploads = load_pending_uploads()
    uploads.append(upload)
    with open(PENDING_UPLOADS_FILE, 'w', encoding='utf-8') as f:
        json.dump(uploads, f, indent=2, ensure_ascii=False)

def remove_pending_upload(user_id, slide_id):
    uploads = load_pending_uploads()
    uploads = [upload for upload in uploads if not (upload['user_id'] == user_id and upload['slide_id'] == slide_id)]
    with open(PENDING_UPLOADS_FILE, 'w', encoding='utf-8') as f:
        json.dump(uploads, f, indent=2, ensure_ascii=False)


async def approve_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if str(query.message.chat_id) != str(ADMIN_CHAT_ID):
        await query.message.reply_text("Bu …ômr yalnƒ±z admin √º√ß√ºn …ôl√ßatandƒ±r.")
        return
    
    try:
        parts = query.data.split('_')
        user_id = int(parts[2])
        slide_id = parts[3]
        
        # M√ºv…ôqq…ôti y√ºkl…ôm…ôl…ôrd…ôn m…ôlumatƒ± tap
        pending_uploads = load_pending_uploads()
        upload = next((u for u in pending_uploads if u['user_id'] == user_id and u['slide_id'] == slide_id), None)
        
        if not upload:
            logger.error(f"Pending upload not found for user ID: {user_id}, slide ID: {slide_id}")
            await query.message.reply_text(f"Y√ºkl…ôm…ô m…ôlumatlarƒ± tapƒ±lmadƒ± (User ID: {user_id}, Slide ID: {slide_id}).")
            return
        file_extension = os.path.splitext(upload['file'])[1].lower()
        # Ensure all required fields exist with default values
        slide = {
            "id": upload['slide_id'],
            "name": upload['name'],
            "category": upload['category'],
            "language": upload.get('language', 'Nam…ôlum'),
            "pages": upload.get('pages', 0),
            "price": upload['price'],
            "card": upload['card'],
            "file": upload['file'],
            "file_type": upload.get('file_type', 'application/pdf'), 
            "file_type": file_extension.replace('.', ''),
            "images": upload['images'],
            "owner": upload['owner'],
            "owner_name": upload['owner_name'],
            "timestamp": upload['timestamp']
        }
        
        save_slide(slide)
        remove_pending_upload(user_id, slide_id)
        
        # User confirmation message
        await context.bot.send_message(
            chat_id=user_id,
            text=f"‚úÖ Sizin slaydƒ±nƒ±z ('{upload['name']}') admin t…ôr…ôfind…ôn t…ôsdiql…ôndi v…ô payla≈üƒ±ldƒ±!\n"
                 "ƒ∞ndi dig…ôr istifad…ô√ßil…ôr axtarƒ±≈ü zamanƒ± slaydƒ±nƒ±zƒ± tapa bil…ôrl…ôr."
        )
        
        # Admin confirmation message
        await query.message.reply_text(f"‚úÖ Slayd (ID: {slide_id}) t…ôsdiql…ôndi v…ô payla≈üƒ±ldƒ±.")
        
        logger.info(f"Admin approved upload for user ID: {user_id}, slide ID: {slide_id}")
        
    except Exception as e:
        logger.error(f"Error approving upload: {e}")
        await query.message.reply_text(f"X…ôta: {str(e)}")
# -- Help Command --
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = (
        "üåü *UniSlayd Bot K√∂m…ôk*\n\n"
        "*∆èsas …ômrl…ôr:*\n"
        "‚Ä¢ /start - Botu yenid…ôn ba≈üladƒ±r\n"
        "‚Ä¢ /help - Bu k√∂m…ôk mesajƒ±nƒ± g√∂st…ôrir\n"
        "‚Ä¢ /cancel - Cari …ôm…ôliyyatƒ± l…ôƒüv edir\n\n"
        
        "*Slayd y√ºkl…ôm…ôk √º√ß√ºn:*\n"
        "1. 'Slayd y√ºkl…ô' d√ºym…ôsini se√ßin\n"
        "2. 30MB-dan ki√ßik slayd faylƒ± g√∂nd…ôrin\n"
        "3. Slaydƒ±n adƒ±nƒ± daxil edin\n"
        "4. Kateqoriya se√ßin (v…ô ya 'Dig…ôr' se√ß…ôr…ôk √∂z kateqoriyanƒ±zƒ± daxil edin)\n"
        "5. √ñd…ôni≈ü almaq √º√ß√ºn kartƒ±nƒ±zƒ±n n√∂mr…ôsini daxil edin\n"
        "6. Slayddan 1-2 √∂nizl…ôm…ô ≈ü…ôkli g√∂nd…ôrin\n\n"
        
        "*Slayd axtarmaq √º√ß√ºn:*\n"
        "1. 'Slayd axtar' d√ºym…ôsini se√ßin\n"
        "2. Ad il…ô axtarƒ±≈ü v…ô ya kateqoriya il…ô axtarƒ±≈ü se√ßin\n"
        "3. Siyahƒ±dan ist…ôdiyiniz slaydƒ± se√ßin\n"
        "4. 'T…ôqdimatƒ± al' d√ºym…ôsini basƒ±n\n"
        "5. G√∂st…ôril…ôn karta √∂d…ôni≈ü edin v…ô q…ôbzin ≈ü…ôklini g√∂nd…ôrin\n"
        "6. Admin √∂d…ôni≈üi t…ôsdiq etdikd…ôn sonra slayd siz…ô g√∂nd…ôril…ôc…ôk\n\n"
        
        "H…ôr hansƒ± bir probleminiz varsa @UniSlayd il…ô …ôlaq…ô saxlayƒ±n."
    )
    
    await update.message.reply_text(
        help_text,
        parse_mode="Markdown"
    )

async def handle_edit_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back_to_slide_action":
        slide = context.user_data.get('selected_slide')
        if not slide:
            await query.message.reply_text("X…ôta: Se√ßilmi≈ü slayd tapƒ±lmadƒ±.")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è D√ºz…ôli≈ü et", callback_data="edit_slide")],
            [InlineKeyboardButton("üóëÔ∏è Sil", callback_data="delete_slide")],
            [InlineKeyboardButton("üîô Geri", callback_data="back_to_slides")]
        ]

        await query.message.reply_text(
            "N…ô etm…ôk ist…ôyirsiniz?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SELECT_SLIDE_ACTION

    field_map = {
        "edit_name": ("Ad", "Yeni adƒ± daxil edin:"),
        "edit_price": ("Qiym…ôt", "Yeni qiym…ôti AZN il…ô daxil edin (m…ôs: 5.5):"),
        "edit_pages": ("S…ôhif…ô sayƒ±", "Yeni s…ôhif…ô sayƒ±nƒ± daxil edin (m…ôs: 15):"),
        "edit_card": ("Kart", "Yeni kart n√∂mr…ôsini daxil edin:")
    }

    if query.data not in field_map:
        await query.message.reply_text("X…ôta: Yanlƒ±≈ü sah…ô se√ßildi.")
        return EDIT_FIELD

    field, prompt = field_map[query.data]
    context.user_data['edit_field'] = field.lower()

    if field == "Kateqoriya":
        keyboard = []
        for i in range(0, len(CATEGORIES), 3):
            row = [
                InlineKeyboardButton(CATEGORIES[j], callback_data=f"edit_category_{CATEGORIES[j]}")
                for j in range(i, min(i + 3, len(CATEGORIES)))
            ]
            keyboard.append(row)
        await query.message.reply_text(prompt, reply_markup=InlineKeyboardMarkup(keyboard))
    elif field == "Dil":
        keyboard = [[InlineKeyboardButton(lang, callback_data=f"edit_language_{lang}")] for lang in LANGUAGES]
        await query.message.reply_text(prompt, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await query.message.reply_text(prompt, reply_markup=ReplyKeyboardRemove())

    return EDIT_VALUE

async def handle_slide_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back_to_slides":
        user_slides = context.user_data.get('user_slides', [])
        if not user_slides:
            await query.message.reply_text("Sizin t…ôqdimatƒ±nƒ±z yoxdur.")
            return ConversationHandler.END

        keyboard = []
        for i, slide in enumerate(user_slides):
            button_text = f"{slide['name']} [Kateqoriya: {slide.get('category', 'Nam…ôlum')}]"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"myslide_{i}")])

        keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])

        await query.message.reply_text(
            f"Sizin {len(user_slides)} t…ôqdimatƒ±nƒ±z tapƒ±ldƒ±:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return MY_SLIDES

    elif query.data == "delete_slide":
        slide = context.user_data.get('selected_slide')
        if not slide:
            await query.message.reply_text("X…ôta: Se√ßilmi≈ü slayd tapƒ±lmadƒ±.")
            return ConversationHandler.END

        try:
            # Load all slides
            slides = load_slides()
            
            # Find and remove the slide
            slides = [s for s in slides if s['id'] != slide['id']]
            
            # Save updated slides list
            with open(DB_FILE, 'w', encoding='utf-8') as f:
                json.dump(slides, f, indent=2, ensure_ascii=False)

            # Delete associated files
            try:
                if os.path.exists(slide['file']):
                    os.remove(slide['file'])
                for img_path in slide.get('images', []):
                    if os.path.exists(img_path):
                        os.remove(img_path)
            except Exception as e:
                logger.error(f"Error deleting files for slide {slide['id']}: {e}")

            await query.message.reply_text(f"‚úÖ Slayd '{slide['name']}' silindi.")
            
            # Update user's slides list
            user_slides = [s for s in slides if s['owner'] == query.from_user.id]
            context.user_data['user_slides'] = user_slides
            
            if user_slides:
                keyboard = []
                for i, s in enumerate(user_slides):
                    button_text = f"{s['name']} [Kateqoriya: {s.get('category', 'Nam…ôlum')}]"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"myslide_{i}")])
                
                keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])
                
                await query.message.reply_text(
                    f"Sizin {len(user_slides)} t…ôqdimatƒ±nƒ±z qaldƒ±:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return MY_SLIDES
            else:
                await query.message.reply_text("Sizin artƒ±q he√ß bir t…ôqdimatƒ±nƒ±z yoxdur.")
                return ConversationHandler.END
                
        except Exception as e:
            logger.error(f"Error deleting slide: {e}")
            await query.message.reply_text("Slaydƒ± silm…ôy…ô √ßalƒ±≈üark…ôn x…ôta ba≈ü verdi.")
            return ConversationHandler.END
        
    elif query.data == "edit_slide":
        keyboard = [
            [InlineKeyboardButton("Ad", callback_data="edit_name")],
            [InlineKeyboardButton("Qiym…ôt", callback_data="edit_price")],
            [InlineKeyboardButton("S…ôhif…ô sayƒ±", callback_data="edit_pages")],
            [InlineKeyboardButton("Kart", callback_data="edit_card")],
            [InlineKeyboardButton("üîô Geri", callback_data="back_to_slide_action")]
        ]

        await query.message.reply_text(
            "Hansƒ± sah…ôni d√ºz…ôltm…ôk ist…ôyirsiniz?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return EDIT_FIELD
    
# Handler for editing category
async def handle_edit_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle language update with improved error handling and UI feedback"""
    query = update.callback_query
    await query.answer()

    try:
        language = query.data.replace("edit_language_", "")
        slide = context.user_data.get('selected_slide')
        if not slide:
            await query.edit_message_text("X…ôta: Se√ßilmi≈ü slayd tapƒ±lmadƒ±.")
            return ConversationHandler.END

        # First, update the UI to show processing
        await query.edit_message_text(f"Dil '{language}' olaraq yenil…ônir... Xahi≈ü edirik g√∂zl…ôyin.")
        
        # Load slides directly from file to ensure we have latest data
        slides = load_slides()
        
        # Find and update the specific slide
        updated = False
        for s in slides:
            if s['id'] == slide['id']:
                s['language'] = language
                # Save the updated slide back to context
                context.user_data['selected_slide'] = s
                updated = True
                break
        
        if not updated:
            await query.edit_message_text("X…ôta: Slayd veril…ônl…ôr bazasƒ±nda tapƒ±lmadƒ±.")
            return ConversationHandler.END

        # Save all slides with explicit error handling
        try:
            with open(DB_FILE, 'w', encoding='utf-8') as f:
                json.dump(slides, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error saving slides to file: {e}")
            await query.edit_message_text(f"Veril…ônl…ôr bazasƒ±nƒ± yadda saxlayark…ôn x…ôta: {str(e)}")
            return ConversationHandler.END

        # Update user's slides list in context
        user_slides = context.user_data.get('user_slides', [])
        for i, s in enumerate(user_slides):
            if s['id'] == slide['id']:
                user_slides[i]['language'] = language
                break
        context.user_data['user_slides'] = user_slides

        # Update UI with success message and options
        keyboard = [
            [InlineKeyboardButton("üîÑ Redakt…ô etm…ôy…ô davam edin", callback_data=f"edit_slide_{slide['id']}")],
            [InlineKeyboardButton("üîô Slaydlara qayƒ±t", callback_data="my_slides")]
        ]
        
        await query.edit_message_text(
            f"‚úÖ Dil '{language}' olaraq uƒüurla yenil…ôndi.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        return MY_SLIDES

    except Exception as e:
        logger.error(f"Error in handle_edit_language: {e}")
        # Provide user with error and recovery option
        keyboard = [[InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")]]
        await query.edit_message_text(
            f"X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.\nX…ôta detallarƒ±: {str(e)}",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ConversationHandler.END

async def handle_edit_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle category update with improved error handling and UI feedback"""
    query = update.callback_query
    await query.answer()

    try:
        category = query.data.replace("edit_category_", "")
        slide = context.user_data.get('selected_slide')
        if not slide:
            await query.edit_message_text("X…ôta: Se√ßilmi≈ü slayd tapƒ±lmadƒ±.")
            return ConversationHandler.END

        # First, update the UI to show processing
        await query.edit_message_text(f"Kateqoriya '{category}' olaraq yenil…ônir... Xahi≈ü edirik g√∂zl…ôyin.")
        
        # Load slides directly from file to ensure we have latest data
        slides = load_slides()
        
        # Find and update the specific slide
        updated = False
        for i, s in enumerate(slides):
            if s['id'] == slide['id']:
                slides[i]['category'] = category
                context.user_data['selected_slide'] = slides[i]  # Update in context
                updated = True
                logger.debug(f"Updated slide ID: {slide['id']} with new category: {category}")
                break
        
        if not updated:
            await query.edit_message_text("X…ôta: Slayd veril…ônl…ôr bazasƒ±nda tapƒ±lmadƒ±.")
            return ConversationHandler.END

        # Save updated slides with explicit error handling
        try:
            save_slides(slides)
        except Exception as e:
            logger.error(f"Error saving slides to file: {e}")
            await query.edit_message_text(f"Veril…ônl…ôr bazasƒ±nƒ± yadda saxlayark…ôn x…ôta: {str(e)}")
            return ConversationHandler.END

        # Update user's slides list in context
        user_slides = context.user_data.get('user_slides', [])
        for i, s in enumerate(user_slides):
            if s['id'] == slide['id']:
                user_slides[i]['category'] = category
                break
        context.user_data['user_slides'] = user_slides

        # Update UI with success message and options
        keyboard = [
            [InlineKeyboardButton("üîÑ Redakt…ô etm…ôy…ô davam edin", callback_data=f"edit_slide_{slide['id']}")],
            [InlineKeyboardButton("üîô Slaydlara qayƒ±t", callback_data="my_slides")]
        ]
        
        await query.edit_message_text(
            f"‚úÖ Kateqoriya '{category}' olaraq uƒüurla yenil…ôndi.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        return MY_SLIDES

    except Exception as e:
        logger.error(f"Error in handle_edit_category: {e}")
        # Provide user with error and recovery option
        keyboard = [[InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")]]
        await query.edit_message_text(
            f"X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.\nX…ôta detallarƒ±: {str(e)}",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ConversationHandler.END

# Helper function to display category selection
async def show_category_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows category selection buttons"""
    query = update.callback_query
    
    # Define available categories
    categories = [
        ["IT", "Riyaziyyat", "Elektronika"],
        ["English", "Biznes v…ô ƒ∞dar…ôetm…ô", "ƒ∞qtisadiyyat"],
        ["Dizayn", "Memarlƒ±q", "Neft-Qaz"],
        ["Dil√ßilik", "Tibb", "Tarix"],
        ["H√ºquq", "S∆èT∆èMM", "Dig…ôr"]
    ]
    
    # Create keyboard with categories
    keyboard = []
    for row in categories:
        keyboard.append([InlineKeyboardButton(cat, callback_data=f"edit_category_{cat}") for cat in row])
    
    keyboard.append([InlineKeyboardButton("üîô Geri", callback_data="edit_slide_back")])
    
    await query.edit_message_text(
        "Yeni kateqoriyanƒ± se√ßin v…ô ya daxil edin:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return EDIT_CATEGORY

# Helper function to display language selection
async def show_language_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows language selection buttons"""
    query = update.callback_query
    
    # Define available languages
    languages = [
        ["Az…ôrbaycan", "English", "–†—É—Å—Å–∫–∏–π"]
    ]
    
    # Create keyboard with languages
    keyboard = []
    for row in languages:
        keyboard.append([InlineKeyboardButton(lang, callback_data=f"edit_language_{lang}") for lang in row])
    
    keyboard.append([InlineKeyboardButton("üîô Geri", callback_data="edit_slide_back")])
    
    await query.edit_message_text(
        "Yeni dili se√ßin:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return EDIT_LANGUAGE

async def handle_edit_value(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    value = update.message.text.strip()
    field = context.user_data.get('edit_field')
    slide = context.user_data.get('selected_slide')

    if not slide or not field:
        await update.message.reply_text("X…ôta: Se√ßilmi≈ü slayd v…ô ya sah…ô tapƒ±lmadƒ±.")
        return ConversationHandler.END

    try:
        # Value validation based on field type
        if field == "qiym…ôt":
            try:
                value = float(value)
                if value <= 0:
                    raise ValueError("Qiym…ôt sƒ±fƒ±rdan b√∂y√ºk olmalƒ±dƒ±r.")
            except ValueError:
                await update.message.reply_text("X…ôta: D√ºzg√ºn qiym…ôt daxil edin (m…ôs…ôl…ôn: 5.5)")
                return EDIT_VALUE
                
        elif field == "s…ôhif…ô sayƒ±":
            try:
                value = int(value)
                if value <= 0:
                    raise ValueError("S…ôhif…ô sayƒ± sƒ±fƒ±rdan b√∂y√ºk olmalƒ±dƒ±r.")
            except ValueError:
                await update.message.reply_text("X…ôta: D√ºzg√ºn s…ôhif…ô sayƒ± daxil edin (m…ôs…ôl…ôn: 15)")
                return EDIT_VALUE
                
        elif not value:
            raise ValueError("D…ôy…ôr bo≈ü ola bilm…ôz.")

        # Load all slides
        slides = load_slides()
        
        # Find and update the specific slide
        for i, s in enumerate(slides):
            if s['id'] == slide['id']:
                # Map field names to database fields
                field_mapping = {
                    "ad": "name",
                    "kateqoriya": "category",
                    "qiym…ôt": "price",
                    "dil": "language",
                    "s…ôhif…ô sayƒ±": "pages",
                    "kart": "card"
                }
                
                # Get the correct database field name
                db_field = field_mapping.get(field, field)
                
                # Update the field
                slides[i][db_field] = value
                
                # Save the updated slides
                with open(DB_FILE, 'w', encoding='utf-8') as f:
                    json.dump(slides, f, indent=2, ensure_ascii=False)
                
                # Update the slide in context
                context.user_data['selected_slide'] = slides[i]
                
                await update.message.reply_text(f"‚úÖ {field.capitalize()} '{value}' olaraq yenil…ôndi.")
                return await my_slides(update, context)
                
        raise ValueError("Slayd tapƒ±lmadƒ±.")

    except ValueError as e:
        await update.message.reply_text(f"X…ôta: {str(e)}")
        return EDIT_VALUE
    except Exception as e:
        logger.error(f"Error updating slide field {field}: {e}")
        await update.message.reply_text("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return ConversationHandler.END

async def my_slides(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    logger.info(f"User {user.id} ({user.full_name}) requested their slides")

    slides = load_slides()
    user_slides = [slide for slide in slides if slide['owner'] == user.id]

    if not user_slides:
        await update.message.reply_text("Siz h…ôl…ô he√ß bir t…ôqdimat payla≈ümamƒ±sƒ±nƒ±z.")
        return ConversationHandler.END

    keyboard = []
    for i, slide in enumerate(user_slides):
        button_text = f"{slide['name']} [Kateqoriya: {slide.get('category', 'Nam…ôlum')}]"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"myslide_{i}")])

    keyboard.append([InlineKeyboardButton("üîô ∆èsas Menyu", callback_data="main_menu")])

    await update.message.reply_text(
        f"Sizin {len(user_slides)} t…ôqdimatƒ±nƒ±z tapƒ±ldƒ±:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    context.user_data['user_slides'] = user_slides
    return MY_SLIDES

# Handler for selecting a slide
async def handle_slide_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        index = int(query.data.replace("myslide_", ""))
        user_slides = context.user_data.get('user_slides', [])
        
        if 0 <= index < len(user_slides):
            slide = user_slides[index]
            context.user_data['selected_slide'] = slide
            
            # Format slide info with default values for missing fields
            slide_info = (
                f"üìë T…ôqdimat m…ôlumatlarƒ±:\n\n"
                f"Ad: {slide.get('name', 'M…ôlumat yoxdur')}\n"
                f"Kateqoriya: {slide.get('category', 'M…ôlumat yoxdur')}\n"
                f"Dil: {slide.get('language', 'M…ôlumat yoxdur')}\n"
                f"S…ôhif…ô sayƒ±: {slide.get('pages', 'M…ôlumat yoxdur')}\n"
                f"Qiym…ôt: {slide.get('price', 'M…ôlumat yoxdur')} AZN\n"
                f"Kart: {slide.get('card', 'M…ôlumat yoxdur')}\n"
                f"Format: {slide.get('file_type', 'M…ôlumat yoxdur')}\n"
                f"Y√ºkl…ônm…ô tarixi: {slide.get('timestamp', 'M…ôlumat yoxdur')}\n"
                f"Satƒ±≈ü sayƒ±: {slide.get('sales', 0)}"
            )
            
            # Show images if available
            if slide.get('images'):
                for image_path in slide['images']:
                    if os.path.exists(image_path):
                        try:
                            await context.bot.send_photo(
                                chat_id=query.message.chat_id,
                                photo=open(image_path, 'rb')
                            )
                        except Exception as e:
                            logger.error(f"Error sending image {image_path}: {e}")
            
            # Create action buttons
            keyboard = [
                [InlineKeyboardButton("‚úèÔ∏è D√ºz…ôli≈ü et", callback_data="edit_slide")],
                [InlineKeyboardButton("üóëÔ∏è Sil", callback_data="delete_slide")],
                [InlineKeyboardButton("üîô Geri", callback_data="back_to_slides")]
            ]
            
            await query.message.reply_text(
                slide_info,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return SELECT_SLIDE_ACTION
        
        else:
            await query.message.reply_text("X…ôta: Se√ßilmi≈ü slayd tapƒ±lmadƒ±.")
            return ConversationHandler.END
            
    except Exception as e:
        logger.error(f"Error in handle_slide_selection: {e}")
        await query.message.reply_text("X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.")
        return ConversationHandler.END


# -- Main App 
def main():
    app = Application.builder().token(TOKEN).build()

    os.makedirs("downloads", exist_ok=True)
    os.makedirs("images", exist_ok=True)
    os.makedirs("payments", exist_ok=True)

    if not os.path.exists("pending_uploads.json"):
        with open("pending_uploads.json", 'w', encoding='utf-8') as f:
            json.dump([], f, indent=2, ensure_ascii=False)

    app.add_error_handler(error_handler)

    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            CommandHandler("mySlides", my_slides),
            CallbackQueryHandler(handle_choice, pattern="^(upload|search)$")
        ],
        states={
            UPLOAD_SLIDE: [MessageHandler(filters.Document.ALL, handle_file)],
            UPLOAD_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_name)],
            UPLOAD_CATEGORY: [
                CallbackQueryHandler(handle_category, pattern=r'^category_'),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_category_text)
            ],
            UPLOAD_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_price)],
            UPLOAD_LANGUAGE: [CallbackQueryHandler(handle_language, pattern=r'^(lang_|back_to_price)')],
            UPLOAD_PAGES: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_pages),
                CallbackQueryHandler(handle_pages, pattern=r'^back_to_language$')
            ],
            UPLOAD_CARD: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_card),
                CallbackQueryHandler(handle_card)
            ],
            UPLOAD_IMAGE: [
                MessageHandler(filters.PHOTO, handle_image),
                CallbackQueryHandler(handle_image_choice, pattern="^(finish_upload|add_more)$"),
                CallbackQueryHandler(handle_card, pattern=r'^back_to_card$')
            ],
            SEARCH_TYPE: [
                CallbackQueryHandler(handle_search_type, pattern="^(search_by_name|search_by_category|search_by_language)$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_by_name)
            ],
            SEARCH_LANGUAGE: [
                CallbackQueryHandler(handle_search_by_language, pattern=r'^search_lang_'),
                CallbackQueryHandler(start, pattern="^main_menu$")
            ],
            SEARCH_CATEGORY: [CallbackQueryHandler(handle_search_category, pattern=r'^search_category_')],
            SEARCH_OTHER_CATEGORY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_other_category)],
            SELECT_SLIDE: [
                CallbackQueryHandler(view_selected_slide, pattern=r'^slide_\d+$'),
                CallbackQueryHandler(start, pattern="^main_menu$")
            ],
            CONFIRM_PAYMENT: [
                CallbackQueryHandler(request_payment, pattern="^buy$"),
                CallbackQueryHandler(back_to_results, pattern="^back_to_results$"),
                MessageHandler(filters.PHOTO, confirm_payment)
            ],
            MY_SLIDES: [
                CallbackQueryHandler(handle_slide_selection, pattern=r'^myslide_\d+$'),
                CallbackQueryHandler(start, pattern="^main_menu$")
            ],
            SELECT_SLIDE_ACTION: [
                CallbackQueryHandler(handle_slide_action, pattern="^(edit_slide|delete_slide|back_to_slides)$")
            ],
            EDIT_FIELD: [
                CallbackQueryHandler(handle_edit_field),
                CallbackQueryHandler(handle_edit_category, pattern=r'^edit_category_\w+'),
                CallbackQueryHandler(handle_edit_language, pattern=r'^edit_language_\w+')
        ],
            EDIT_VALUE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_edit_value)
            ]
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("start", start)
        ]
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CallbackQueryHandler(approve_payment, pattern=r'^approve_payment_\d+$'))
    app.add_handler(CallbackQueryHandler(reject_payment, pattern=r'^reject_payment_\d+$'))
    app.add_handler(CallbackQueryHandler(approve_upload, pattern=r'^approve_upload_\d+_[0-9a-f-]+$'))
    app.add_handler(CallbackQueryHandler(reject_upload, pattern=r'^reject_upload_\d+_[0-9a-f-]+$'))

    logger.info("Bot i≈ü…ô d√º≈üd√º...")
    app.run_polling()


if __name__ == '__main__':
    main() 